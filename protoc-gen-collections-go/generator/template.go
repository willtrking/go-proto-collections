package generator

import "text/template"

var fileHeaderTemplate = template.Must(template.New("fileHeader").Parse(`// Code generated by protoc-gen-collections-go
// source: {{.Source}}
// DO NOT EDIT!

package {{.GoPackage}}
import (
	"fmt"
	"errors"
	"github.com/golang/protobuf/proto"
	"github.com/willtrking/go-proto-collections/helpers"
	pgcol "github.com/willtrking/go-proto-collections/protocollections"

)
`))

var parentMessageTemplate = template.Must(template.New("parentMessage").Parse(`func (p *{{.ParentGoName}}) DefaultCollectionMap() map[string]helpers.CollectionElem {
	m := make(map[string]helpers.CollectionElem)


	{{ range .Collections }}
	m["{{.CollectionName}}"] = &{{.CollectionGoType}}{}
	{{ end }}

	return m
}

func (p *{{.ParentGoName}}) CollectionKeys() []string {
	return []string{
		{{ range .Collections }}
		"{{.CollectionName}}",
		{{ end }}
	}
}

func (p *{{.ParentGoName}}) LoadCollection(collection string, data []interface{}) error {

	if p.{{.ParentGoCollectionAttr}} == nil {
		p.{{.ParentGoCollectionAttr}} = &{{.ParentCollectionGoType}}{}
	}

	switch collection {
	{{ range .Collections }}
	case "{{.CollectionName}}":
		p.{{.ParentGoCollectionAttr}}.{{.CollectionGoName}} = &{{.CollectionGoType}}{}
		p.{{.ParentGoCollectionAttr}}.{{.CollectionGoName}}.LoadData(data)
		return nil	
	{{ end }}
	default:
		return errors.New(fmt.Sprintf("Unknown collection %s", collection))
	}

}

func (p *{{.ParentGoName}}) CollectionInterfaceSlice(collection string) []interface{} {
	if p.{{.ParentGoCollectionAttr}} == nil {
		return nil
	}

	switch collection {
	{{ range .Collections }}
	case "{{.CollectionName}}":
		if p.{{.ParentGoCollectionAttr}}.{{.CollectionGoName}} == nil {
			return nil
		} else {
			return p.{{.ParentGoCollectionAttr}}.{{.CollectionGoName}}.InterfaceSlice()
		}
	{{ end }}
	default:
		return nil
	}

}

func (p *{{.ParentGoName}}) CollectionProtoSlice(collection string) []proto.Message {
	if p.{{.ParentGoCollectionAttr}} == nil {
		return nil
	}

	switch collection {
	{{ range .Collections }}
	case "{{.CollectionName}}":
		if p.{{.ParentGoCollectionAttr}}.{{.CollectionGoName}} == nil {
			return nil
		} else {
			return p.{{.ParentGoCollectionAttr}}.{{.CollectionGoName}}.ProtoSlice()
		}
	{{ end }}
	default:
		return nil
	}

}

func (p *{{.ParentGoName}}) CollectionElem(collection string) helpers.CollectionElem {
	if p.{{.ParentGoCollectionAttr}} == nil {
		return nil
	}

	switch collection {
	{{ range .Collections }}
	case "{{.CollectionName}}":
		if p.{{.ParentGoCollectionAttr}}.{{.CollectionGoName}} == nil {
			return nil
		} else {
			return p.{{.ParentGoCollectionAttr}}.{{.CollectionGoName}}
		}
	{{ end }}
	default:
		return nil
	}

}

func (p *{{.ParentGoName}}) SetCollectionParentKeyData(d interface{}, collection string) {
	switch collection {
	{{ range .Collections }}
	case "{{.CollectionName}}":
		p.{{.ParentGoKey}} = d.({{.ParentKeyGoType}})
	{{ end }}
	}
}

func (p *{{.ParentGoName}}) SetCollectionKeyData(pb interface{}, d interface{}, collection string) {
	switch collection {
	{{ range .Collections }}
	case "{{.CollectionName}}":
		pb.(*{{.CollectionDataTypeGoName}}).{{.CollectionGoKey}} = d.({{.CollectionKeyGoType}})
	{{ end }}
	}
}

func (p *{{.ParentGoName}}) SetCollectionKeyDataFromParent(pb interface{}, collection string) string {
	switch collection {
	{{ range .Collections }}
	case "{{.CollectionName}}":
		pb.(*{{.CollectionDataTypeGoName}}).{{.CollectionGoKey}} = p.{{.ParentGoKey}}
		return "{{.CollectionKey}}"
	{{ end }}
	}
	
	return ""
}

//Get the data for a collection from the parent, which is this protobuf
func (p *{{.ParentGoName}}) CollectionParentKeyData(collection string) interface{} {
	switch collection {
	{{ range .Collections }}
	case "{{.CollectionName}}":
		return p.{{.ParentGoKey}}
	{{ end }}
	default:
		return nil
	}
}

//Check if key belonging to the the parent (this protobuf) is default
func (p *{{.ParentGoName}}) CollectionParentKeyIsDefault(collection string) bool {
	switch collection {
	{{ range .Collections }}
	case "{{.CollectionName}}":
		return p.{{.ParentGoKey}} == {{.ParentKeyGoDefault}}
	{{ end }}
	default:
		return false
	}
}

//Check if the key belonging to an element that could be in the collection is default
//Will panic if pb is not the proper type, OR pb is nil, as it should
func (p *{{.ParentGoName}}) CollectionKeyIsDefault(pb interface{}, collection string) bool {
	switch collection {
	{{ range .Collections }}
	case "{{.CollectionName}}":
		return pb.(*{{.CollectionDataTypeGoName}}).{{.CollectionGoKey}} == {{.CollectionKeyGoDefault}}
	{{ end }}
	default:
		return false
	}
}

//Get the data for a collection from an element that could be in the collection
//Will panic if pb is not the proper type, as it should
func (p *{{.ParentGoName}}) CollectionKeyData(pb interface{}, collection string) interface{} {
	switch collection {
	{{ range .Collections }}
	case "{{.CollectionName}}":
		if pb == nil {
			return nil 
		} else {
			return pb.(*{{.CollectionDataTypeGoName}}).{{.CollectionGoKey}}
		}
	{{ end }}
	default:
		return nil
	}
}

func (p *{{.ParentGoName}}) ProtoBelongsToCollection(pb interface{}, collection string) bool {
	switch collection {
	{{ range .Collections }}
	case "{{.CollectionName}}":

		if c, ok := pb.(*{{.CollectionDataTypeGoName}}); ok {
			return c.{{.CollectionGoKey}} == p.{{.ParentGoKey}}
		} else {
			return false
		}
	{{ end }}
	default:
		return false
	}
}
`))

var listableCollectionTemplate = template.Must(template.New("listableCollection").Parse(`func (*{{.CollectionGoType}}) DefaultDetails() *pgcol.CollectionDetails {
	return &pgcol.CollectionDetails{
		ParentKey:     "{{.ParentKey}}",
		CollectionKey: "{{.CollectionKey}}",
		Listable:      true,
		Loaded:        false,
		MaxResults:     {{.MaxResults}},
		NextRPC:       "{{.NextRPC}}",
		NextBody:      nil,
	}
}

func (*{{.CollectionGoType}}) DataProto() proto.Message {
	return &{{.CollectionDataTypeGoName}}{}
}

func (c *{{.CollectionGoType}}) LoadData(data []interface{}) {

	c.{{.CollectionDetailsGoName}} = c.DefaultDetails()

	dL := len(data)

	if dL > 0 {

		c.{{.CollectionDataGoName}} = make([]*{{.CollectionDataTypeGoName}}, dL)

		for i, v := range data {
			if v != nil {
				c.{{.CollectionDataGoName}}[i] = v.(*{{.CollectionDataTypeGoName}})
			}
		}

		cL := len(c.{{.CollectionDataGoName}})

		if cL > 0 {
			if cL != dL {
				d := make([]*{{.CollectionDataTypeGoName}}, cL)
				copy(d, c.{{.CollectionDataGoName}})
				c.{{.CollectionDataGoName}} = nil
				c.{{.CollectionDataGoName}} = d
			}
		} else {
			c.{{.CollectionDataGoName}} = nil
		}

		c.{{.CollectionDetailsGoName}}.Loaded = true

	} else {
		c.{{.CollectionDetailsGoName}}.Loaded = true
	}

}

func (c *{{.CollectionGoType}}) InterfaceSlice() []interface{} {
	if c.Data != nil {
		s := make([]interface{},len(c.Data))
		for idx, d := range c.Data {
			s[idx] = d
		}
		return s
	} else {
		return []interface{}{}
	}
}

func (c *{{.CollectionGoType}}) ProtoSlice() []proto.Message {
	if c.Data != nil {
		s := make([]proto.Message,len(c.Data))
		for idx, d := range c.Data {
			s[idx] = d
		}
		return s
	} else {
		return []proto.Message{}
	}
}
`))

var collectionTemplate = template.Must(template.New("collection").Parse(`func (*{{.CollectionGoType}}) DefaultDetails() *pgcol.CollectionDetails {
	return &pgcol.CollectionDetails{
		ParentKey:     "{{.ParentKey}}",
		CollectionKey: "{{.CollectionKey}}",
		Listable:      false,
		Loaded:        false,
		MaxResults:     {{.MaxResults}},
		NextRPC:       "{{.NextRPC}}",
		NextBody:      nil,
	}
}

func (*{{.CollectionGoType}}) DataProto() proto.Message {
	return &{{.CollectionDataTypeGoName}}{}
}

func (c *{{.CollectionGoType}}) LoadData(data []interface{}) {

	c.{{.CollectionDetailsGoName}} = c.DefaultDetails()
	c.{{.CollectionDetailsGoName}}.Loaded = false

	if len(data) > 0 {
		for _, v := range data {
			if v != nil {
				c.{{.CollectionDataGoName}} = v.(*{{.CollectionDataTypeGoName}})
				c.{{.CollectionDetailsGoName}}.Loaded = true
				break
			}
		}

		if c.{{.CollectionDetailsGoName}}.Loaded != true {
			c.{{.CollectionDataGoName}} = &{{.CollectionDataTypeGoName}}{}
			c.{{.CollectionDetailsGoName}}.Loaded = true
		}
		

	} else {
		c.{{.CollectionDataGoName}} = &{{.CollectionDataTypeGoName}}{}
		c.{{.CollectionDetailsGoName}}.Loaded = true
	}

}

func (c *{{.CollectionGoType}}) InterfaceSlice() []interface{} {
	if c.Data != nil {
		s := make([]interface{},1)
		s[0] = c.Data
		return s
	} else {
		var s []interface{}
		return s
	}
}

func (c *{{.CollectionGoType}}) ProtoSlice() []proto.Message {
	if c.Data != nil {
		s := make([]proto.Message,1)
		s[0] = c.Data
		return s
	} else {
		var s []proto.Message
		return s
	}
}
`))

var listableCollectionMessageSliceImplementingTemplate = template.Must(template.New("collectionMessageSliceImplementingTemplate").Parse(`func (c *{{.CollectionGoType}}) CollectionMessageSlice() []helpers.CollectionMessage {
	if c.Data != nil {
		s := make([]helpers.CollectionMessage,len(c.Data))
		for idx, d := range c.Data {
			s[idx] = d
		}
		return s
	}

	return nil
	
}

func (c *{{.CollectionGoType}}) DataIsCollectionMessage() bool {
	return true
}
`))

var collectionMessageSliceImplementingTemplate = template.Must(template.New("collectionMessageSliceImplementingTemplate").Parse(`func (c *{{.CollectionGoType}}) CollectionMessageSlice() []helpers.CollectionMessage {
	if c.Data != nil {
		s := make([]helpers.CollectionMessage,1)
		s[0] = c.Data
		return s
	}

	return nil
	
}

func (c *{{.CollectionGoType}}) DataIsCollectionMessage() bool {
	return true
}
`))

var collectionMessageSliceNotImplementingTemplate = template.Must(template.New("collectionMessageSliceNotImplementingTemplate").Parse(`func (c *{{.CollectionGoType}}) CollectionMessageSlice() []helpers.CollectionMessage {
	return nil
}

func (c *{{.CollectionGoType}}) DataIsCollectionMessage() bool {
	return false
}
`))

var collectionGapTemplate = template.Must(template.New("collectonGap").Parse(`func (g *{{.GapGoName}}) GapBridge() helpers.CollectionMessage {
	return g.{{.GapGoAttribute}}
}

func (g *{{.GapGoName}}) DefaultCollectionMap() map[string]helpers.CollectionElem {
	return g.{{.GapGoAttribute}}.DefaultCollectionMap()
}

func (g *{{.GapGoName}}) CollectionKeys() []string {
	return g.{{.GapGoAttribute}}.CollectionKeys()
}

func (g *{{.GapGoName}}) LoadCollection(collection string, data []interface{}) error {
	return g.{{.GapGoAttribute}}.LoadCollection(collection, data)
}

func (g *{{.GapGoName}}) CollectionElem(collection string) helpers.CollectionElem{
	return g.{{.GapGoAttribute}}.CollectionElem(collection)
}

func (g *{{.GapGoName}}) CollectionInterfaceSlice(collection string) []interface{} {
	return g.{{.GapGoAttribute}}.CollectionInterfaceSlice(collection)
}

func (g *{{.GapGoName}}) CollectionProtoSlice(collection string) []proto.Message {
	return g.{{.GapGoAttribute}}.CollectionProtoSlice(collection)
}

func (g *{{.GapGoName}}) SetCollectionParentKeyData(d interface{}, collection string) {
	g.{{.GapGoAttribute}}.SetCollectionParentKeyData(d, collection)
}

func (g *{{.GapGoName}}) SetCollectionKeyData(pb interface{}, d interface{}, collection string) {
	g.{{.GapGoAttribute}}.SetCollectionKeyData(pb, d, collection)
}
func (g *{{.GapGoName}}) SetCollectionKeyDataFromParent(pb interface{}, collection string) string {
	return g.{{.GapGoAttribute}}.SetCollectionKeyDataFromParent(pb, collection)
}

func (g *{{.GapGoName}}) CollectionParentKeyData(collection string) interface{} {
	return g.{{.GapGoAttribute}}.CollectionParentKeyData(collection)
}

func (g *{{.GapGoName}}) CollectionParentKeyIsDefault(collection string) bool {
	return g.{{.GapGoAttribute}}.CollectionParentKeyIsDefault(collection)
}

func (g *{{.GapGoName}}) CollectionKeyIsDefault(pb interface{}, collection string) bool {
	return g.{{.GapGoAttribute}}.CollectionKeyIsDefault(pb, collection)
}

func (g *{{.GapGoName}}) CollectionKeyData(pb interface{}, collection string) interface{} {
	return g.{{.GapGoAttribute}}.CollectionKeyData(pb, collection)
}

func (g *{{.GapGoName}}) ProtoBelongsToCollection(pb interface{}, collection string) bool {
	return g.{{.GapGoAttribute}}.ProtoBelongsToCollection(pb, collection)
}
`))

var collectionLoaderTemplate = template.Must(template.New("collectonLoader").Parse(`// Code generated by protoc-gen-collections-go
// DO NOT EDIT!

package {{.GoPackage}}

import (
	"fmt"
	"sync"
	"errors"
	"github.com/willtrking/go-proto-collections/runtime"
)



////////////////////////////////////////////////////////////////////////////////
///// IMPLEMENT THIS INTERFACE!!
////////////////////////////////////////////////////////////////////////////////

type {{.CollectionDataTypeGoName}}Loader interface {
	{{ range .CLTypes }}
	From{{.CollectionGoKey}}(string, []{{.CollectionKeyGoType}}, chan []*{{.CollectionDataTypeGoName}})
	{{ end }}	
}


////////////////////////////////////////////////////////////////////////////////
///// CALL THIS WITH THE IMPLEMENTATION OF ABOVE INTERFACE!!
////////////////////////////////////////////////////////////////////////////////

func Register{{.CollectionDataTypeGoName}}_Loader(r *runtime.CollectionRegistry, l {{.CollectionDataTypeGoName}}Loader) {
	{{ range .CLRegisterTypes }}
	r.RegisterLoader(&{{.CollectionGoType}}{}, New{{.CollectionDataTypeGoName}}_Loader(l))
	{{ end }}
}





type {{.CollectionDataTypeGoName}}_Loader struct {
	dataKey  string
	loadLock sync.Mutex
	waitLock sync.Mutex
	loading  bool
	loaded   bool
	once     sync.Once
	Data     []*{{.CollectionDataTypeGoName}}
	Loader   {{.CollectionDataTypeGoName}}Loader
}

func (c *{{.CollectionDataTypeGoName}}_Loader) DataKey() string { return c.dataKey }
func (c *{{.CollectionDataTypeGoName}}_Loader) Loading() bool { return c.loading }
func (c *{{.CollectionDataTypeGoName}}_Loader) Loaded() bool  { return c.loaded }
func (c *{{.CollectionDataTypeGoName}}_Loader) Wait() {
	c.waitLock.Lock()
	defer c.waitLock.Unlock()
}

func (c *{{.CollectionDataTypeGoName}}_Loader) SetDataKey(key string) error {

	switch key {
	{{ range .CLTypes }}
	case "{{.CollectionKey}}":
		c.dataKey = key
		return nil
	{{ end }}
	default:
		return errors.New(fmt.Sprintf("Unknown key %s",key))
	}

	return nil
}

func (c *{{.CollectionDataTypeGoName}}_Loader) InterfaceSlice() []interface{} {

	dL := len(c.Data)

	if dL > 0 {
		f := make([]interface{}, dL)

		for i, dI := range c.Data {
			func(y interface{}) {
				f[i] = y
			}(&*dI)
		}

		return f
	} else {
		return nil
	}

}


func (c *{{.CollectionDataTypeGoName}}_Loader) Load(from []interface{}) {
	//Need to acquire a lock here so we wait until the first call is done
	//Provides safety for InterfaceSlice()
	c.loadLock.Lock()
	defer c.loadLock.Unlock()

	loader := func() {
		c.loading = true
		defer func() { c.loading = false }()
		defer func() { c.loaded = true }()
		defer c.waitLock.Unlock()

		switch c.dataKey {
		{{ range .CLTypes }}
		case "{{.CollectionKey}}":
			var a []{{.CollectionKeyGoType}}
			lc := make(chan []*{{.CollectionDataTypeGoName}},1)

			for _, f := range from {
				if f != nil {
					a = append(a,f.({{.CollectionKeyGoType}}))
				}
			}
			
			if a != nil && len(a) > 0 {
				go c.Loader.From{{.CollectionGoKey}}("{{.CollectionKey}}",a,lc)
				c.Data = <-lc
			}
		{{ end }}
		default:
			c.Data = nil	
		}

	}

	c.once.Do(loader)

}

func New{{.CollectionDataTypeGoName}}_Loader(l {{.CollectionDataTypeGoName}}Loader) func(string) (runtime.CollectionLoader,error) {

	return func(k string) (runtime.CollectionLoader,error) {
		f := &{{.CollectionDataTypeGoName}}_Loader{
			dataKey:  "",
			loadLock: sync.Mutex{},
			waitLock: sync.Mutex{},
			loading:  false,
			loaded:   false,
			once:     sync.Once{},
			Data:     []*{{.CollectionDataTypeGoName}}{},
			Loader:   l,
		}

		kErr := f.SetDataKey(k)
		if kErr != nil {
			return nil,kErr
		}

		f.waitLock.Lock()

		return f,nil
	}
}

`))

var collectionWriterTemplate = template.Must(template.New("collectionWriterTemplate").Parse(`// Code generated by protoc-gen-collections-go
// DO NOT EDIT!

package {{.GoPackage}}

import (
	"sync"
	"golang.org/x/net/context"
	"github.com/golang/protobuf/proto"
	"github.com/willtrking/go-proto-collections/runtime"
	"github.com/willtrking/go-proto-collections/helpers"
)


type {{.CollectionDataTypeGoName}}_Writer_Response struct {
	Original *{{.CollectionDataTypeGoName}}
	New *{{.CollectionDataTypeGoName}}
}

{{ range .CLTypes }}

type {{.CollectionDataTypeGoName}}_{{.ParentGoName}} struct {
	Data *{{.CollectionDataTypeGoName}}
	Parent *{{.ParentGoName}}
}

type {{.CollectionDataTypeGoName}}_{{.ParentGoName}}_Response struct {
	Original *{{.CollectionDataTypeGoName}}_{{.ParentGoName}}
	Data *{{.CollectionDataTypeGoName}}
	Parent *{{.ParentGoName}}
}

func(cwd *{{.CollectionDataTypeGoName}}_{{.ParentGoName}}) DataMessage() proto.Message{
	return cwd.Data
}

func(cwd *{{.CollectionDataTypeGoName}}_{{.ParentGoName}}) ParentMessage() helpers.CollectionMessage{
	return cwd.Parent
}


////////////////////////////////////////////////////////////////////////////////
///// IMPLEMENT THIS INTERFACE!!
////////////////////////////////////////////////////////////////////////////////

type {{.CollectionDataTypeGoName}}_{{.ParentGoName}}_Writer interface {
	Validate(context.Context, []*{{.CollectionDataTypeGoName}}_{{.ParentGoName}}) (context.Context, []runtime.WriterError)
	CheckPrecondition(context.Context, []*{{.CollectionDataTypeGoName}}_{{.ParentGoName}}) (context.Context, []runtime.WriterError)
	Write(context.Context, []*{{.CollectionDataTypeGoName}}_{{.ParentGoName}}) ([]*{{.CollectionDataTypeGoName}}_{{.ParentGoName}}_Response, []runtime.WriterError)
}

////////////////////////////////////////////////////////////////////////////////
///// CALL THIS WITH THE IMPLEMENTATION OF ABOVE INTERFACE!!
////////////////////////////////////////////////////////////////////////////////

func Register{{.CollectionDataTypeGoName}}_{{.ParentGoName}}_Writer(r *runtime.CollectionRegistry, l {{.CollectionDataTypeGoName}}_{{.ParentGoName}}_Writer) {
	
	r.RegisterWriter(&{{.CollectionGoType}}{}, New{{.CollectionGoType}}_Writer(l))
	
}

{{ end }}




{{ range .CLTypes }}

type {{.CollectionGoType}}_Writer struct {
	readLock sync.Mutex
	validateLock sync.Mutex
	preconLock sync.Mutex
	writeLock sync.Mutex
	readWait sync.Mutex
	validateWait sync.Mutex
	preconWait sync.Mutex
	writeWait sync.Mutex
	validateWaitUnlockOnce sync.Once
	preconWaitUnlockOnce sync.Once
	writeWaitUnlockOnce sync.Once
	readOnce sync.Once
	validateHadErrors bool
	preconHadErrors bool
	writeHadErrors bool
	reading  bool
	didRead   bool
	Data     []*{{.CollectionDataTypeGoName}}_{{.ParentGoName}}
	WriterResponse []helpers.CollectionWriterData
	Writer   {{.CollectionDataTypeGoName}}_{{.ParentGoName}}_Writer
}

func (c *{{.CollectionGoType}}_Writer) Reading() bool { return c.reading }
func (c *{{.CollectionGoType}}_Writer) DidRead() bool  { return c.didRead }


func (c *{{.CollectionGoType}}_Writer) InterfaceSlice() []interface{} {

	dL := len(c.Data)

	if dL > 0 {
		f := make([]interface{}, dL)

		for i, dI := range c.Data {
			func(y interface{}) {
				f[i] = y
			}(&*dI.Data)
		}

		return f
	} else {
		return nil
	}

}

func (c *{{.CollectionGoType}}_Writer) ProtoSlice() []proto.Message {

	dL := len(c.Data)

	if dL > 0 {
		f := make([]proto.Message, dL)

		for i, dI := range c.Data {
			f[i] = dI.Data
		}

		return f
	} else {
		return nil
	}

}


func (c *{{.CollectionGoType}}_Writer) Read(data []proto.Message, parents []proto.Message) {
	//Need to acquire a lock here so we wait until the first call is done
	//Provides safety for other functions in the chain
	c.readLock.Lock()
	defer c.readLock.Unlock()

	//reader := func() {
		c.reading = true
		defer func() { c.reading = false }()
		defer func() { c.didRead = true }()
		//defer c.readWait.Unlock()

		c.Data = make([]*{{.CollectionDataTypeGoName}}_{{.ParentGoName}}, len(data))

		for idx, f := range data {
			c.Data[idx] = &{{.CollectionDataTypeGoName}}_{{.ParentGoName}}{
				Data: f.(*{{.CollectionDataTypeGoName}}),
				Parent: parents[idx].(*{{.ParentGoName}}),
			}

		}

	//}

	//c.readOnce.Do(reader)

}

func (c *{{.CollectionGoType}}_Writer) ReadAgain() {
	newWait := sync.Mutex{}
	newWait.Lock()
	c.readOnce = sync.Once{}
	c.readWait = newWait
}

func (c *{{.CollectionGoType}}_Writer) WaitRead() {
	c.readWait.Lock()
	defer c.readWait.Unlock()
}

func (c *{{.CollectionGoType}}_Writer) Validate(ctx context.Context) (context.Context, []runtime.WriterError) {
	c.validateLock.Lock()
	defer c.validateLock.Unlock()

	nCtx, err := c.Writer.Validate(ctx, c.Data)

	if len(err) > 0 {
		c.validateHadErrors = true
	} else {
		c.validateHadErrors = false
	}

	return nCtx, err
}

func (c *{{.CollectionGoType}}_Writer) ValidateUnlockWait() {
	ul := func() {
		c.validateWait.Unlock()
	}

	c.validateWaitUnlockOnce.Do(ul)
}

func (c *{{.CollectionGoType}}_Writer) ValidateHadErrors() bool {
	return c.validateHadErrors
}

func (c *{{.CollectionGoType}}_Writer) SetValidateHadErrors(v bool) {
	c.validateHadErrors = v
}

func (c *{{.CollectionGoType}}_Writer) WaitValidate() {
	c.validateWait.Lock()
	defer c.validateWait.Unlock()
}


func (c *{{.CollectionGoType}}_Writer) CheckPrecondition(ctx context.Context) (context.Context, []runtime.WriterError) {
	c.preconLock.Lock()
	defer c.preconLock.Unlock()

	nCtx, err := c.Writer.CheckPrecondition(ctx, c.Data)

	if len(err) > 0 {
		c.preconHadErrors = true
	} else {
		c.preconHadErrors = false
	}

	return nCtx, err
}

func (c *{{.CollectionGoType}}_Writer) PreconditionUnlockWait() {
	ul := func() {
		c.preconWait.Unlock()
	}

	c.preconWaitUnlockOnce.Do(ul)
}

func (c *{{.CollectionGoType}}_Writer) WaitPrecondition() {
	c.preconWait.Lock()
	defer c.preconWait.Unlock()
}

func (c *{{.CollectionGoType}}_Writer) PreconditionHadErrors() bool {
	return c.preconHadErrors
}

func (c *{{.CollectionGoType}}_Writer) SetPreconditionHadErrors(v bool) {
	c.preconHadErrors = v
}

func (c *{{.CollectionGoType}}_Writer) Write(ctx context.Context) []runtime.WriterError {
	c.writeLock.Lock()
	defer c.writeLock.Unlock()

	response, err := c.Writer.Write(ctx, c.Data)

	if len(err) > 0 {
		c.writeHadErrors = true
		return err
	} else {
		c.writeHadErrors = false
	}

	//response := make([]helpers.CollectionWriterData,len(response))

	for _, r := range response {
		*r.Original.Data = *r.Data
		*r.Original.Parent = *r.Parent
	}

	return nil
	
}

func (c *{{.CollectionGoType}}_Writer) WriteResponse() []helpers.CollectionWriterData {
	return c.WriterResponse
}

func (c *{{.CollectionGoType}}_Writer) WriteUnlockWait() {
	ul := func() {
		c.writeWait.Unlock()
	}

	c.writeWaitUnlockOnce.Do(ul)
}

func (c *{{.CollectionGoType}}_Writer) WaitWrite() {
	c.writeWait.Lock()
	defer c.writeWait.Unlock()
}

func (c *{{.CollectionGoType}}_Writer) WriteHadErrors() bool {
	return c.writeHadErrors
}

func (c *{{.CollectionGoType}}_Writer) SetWriteHadErrors(v bool) {
	c.writeHadErrors = v
}

func New{{.CollectionGoType}}_Writer(l {{.CollectionDataTypeGoName}}_{{.ParentGoName}}_Writer) func() (runtime.CollectionWriter,error) {

	return func() (runtime.CollectionWriter,error) {
		f := &{{.CollectionGoType}}_Writer{
			readLock: sync.Mutex{},
			validateLock: sync.Mutex{},
			preconLock: sync.Mutex{},
			writeLock: sync.Mutex{},
			readWait: sync.Mutex{},
			validateWait: sync.Mutex{},
			preconWait: sync.Mutex{},
			writeWait: sync.Mutex{},
			readOnce:     sync.Once{},
			validateWaitUnlockOnce:     sync.Once{},
			preconWaitUnlockOnce:     sync.Once{},
			writeWaitUnlockOnce:     sync.Once{},
			validateHadErrors: false,
			preconHadErrors: false,
			writeHadErrors: false,
			reading:  false,
			didRead:   false,
			Data:     []*{{.CollectionDataTypeGoName}}_{{.ParentGoName}}{},
			WriterResponse: []helpers.CollectionWriterData{},
			Writer:   l,
		}

		f.readWait.Lock()
		f.validateWait.Lock()
		f.preconWait.Lock()
		f.writeWait.Lock()

		return f,nil
	}
}

{{ end }}
`))
