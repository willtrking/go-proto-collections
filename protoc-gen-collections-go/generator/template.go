package generator

import "text/template"

var fileHeaderTemplate = template.Must(template.New("fileHeader").Parse(`// Code generated by protoc-gen-collections-go
// source: {{.Source}}
// DO NOT EDIT!

package {{.GoPackage}}
import (
	"fmt"
	"errors"
	"github.com/golang/protobuf/proto"
	"github.com/willtrking/go-proto-collections/helpers"
	pgcol "github.com/willtrking/go-proto-collections/protocollections"

)
`))

var parentMessageTemplate = template.Must(template.New("parentMessage").Parse(`func (p *{{.ParentGoName}}) DefaultCollectionMap() map[string]helpers.CollectionElem {
	m := make(map[string]helpers.CollectionElem)


	{{ range .Collections }}
	m["{{.CollectionName}}"] = &{{.CollectionGoType}}{}
	{{ end }}

	return m
}

func (p *{{.ParentGoName}}) CollectionContainer() proto.Message {
	if p == nil || p.{{.ParentGoCollectionAttr}} == nil {
		return nil
	}

	return p.{{.ParentGoCollectionAttr}}
}

func (p *{{.ParentGoName}}) CollectionKeys() []string {
	return []string{
		{{ range .Collections }}
		"{{.CollectionName}}",
		{{ end }}
	}
}

func (p *{{.ParentGoName}}) LoadCollection(collection string, data []interface{}) error {

	if p.{{.ParentGoCollectionAttr}} == nil {
		p.{{.ParentGoCollectionAttr}} = &{{.ParentCollectionGoType}}{}
	}

	switch collection {
	{{ range .Collections }}
	case "{{.CollectionName}}":
		p.{{.ParentGoCollectionAttr}}.{{.CollectionGoName}} = &{{.CollectionGoType}}{}
		p.{{.ParentGoCollectionAttr}}.{{.CollectionGoName}}.LoadData(data)
		return nil	
	{{ end }}
	default:
		return errors.New(fmt.Sprintf("Unknown collection %s", collection))
	}

}

func (p *{{.ParentGoName}}) ClearCollection(collection string) error {

	if p.{{.ParentGoCollectionAttr}} == nil {
		p.{{.ParentGoCollectionAttr}} = &{{.ParentCollectionGoType}}{}
	}

	switch collection {
	{{ range .Collections }}
	case "{{.CollectionName}}":
		if p.{{.ParentGoCollectionAttr}}.{{.CollectionGoName}} != nil {
			p.{{.ParentGoCollectionAttr}}.{{.CollectionGoName}}.ClearData()
			p.{{.ParentGoCollectionAttr}}.{{.CollectionGoName}} = nil
			p.{{.ParentGoCollectionAttr}}.{{.CollectionGoName}} = &{{.CollectionGoType}}{}
		}
		return nil	
	{{ end }}
	default:
		return errors.New(fmt.Sprintf("Unknown collection %s", collection))
	}
}


func (p *{{.ParentGoName}}) LoadCollectionFromProto(collection string, data []proto.Message) error {

	if p.{{.ParentGoCollectionAttr}} == nil {
		p.{{.ParentGoCollectionAttr}} = &{{.ParentCollectionGoType}}{}
	}

	switch collection {
	{{ range .Collections }}
	case "{{.CollectionName}}":
		p.{{.ParentGoCollectionAttr}}.{{.CollectionGoName}} = &{{.CollectionGoType}}{}
		p.{{.ParentGoCollectionAttr}}.{{.CollectionGoName}}.LoadDataFromProto(data)
		return nil	
	{{ end }}
	default:
		return errors.New(fmt.Sprintf("Unknown collection %s", collection))
	}

}

func (p *{{.ParentGoName}}) CollectionInterfaceSlice(collection string) []interface{} {
	if p.{{.ParentGoCollectionAttr}} == nil {
		return nil
	}

	switch collection {
	{{ range .Collections }}
	case "{{.CollectionName}}":
		if p.{{.ParentGoCollectionAttr}}.{{.CollectionGoName}} == nil {
			return nil
		} else {
			return p.{{.ParentGoCollectionAttr}}.{{.CollectionGoName}}.InterfaceSlice()
		}
	{{ end }}
	default:
		return nil
	}

}

func (p *{{.ParentGoName}}) CollectionProtoSlice(collection string) []proto.Message {
	if p.{{.ParentGoCollectionAttr}} == nil {
		return nil
	}

	switch collection {
	{{ range .Collections }}
	case "{{.CollectionName}}":
		if p.{{.ParentGoCollectionAttr}}.{{.CollectionGoName}} == nil {
			return nil
		} else {
			return p.{{.ParentGoCollectionAttr}}.{{.CollectionGoName}}.ProtoSlice()
		}
	{{ end }}
	default:
		return nil
	}

}

func (p *{{.ParentGoName}}) CollectionElem(collection string) helpers.CollectionElem {
	if p.{{.ParentGoCollectionAttr}} == nil {
		return nil
	}

	switch collection {
	{{ range .Collections }}
	case "{{.CollectionName}}":
		if p.{{.ParentGoCollectionAttr}}.{{.CollectionGoName}} == nil {
			return nil
		} else {
			return p.{{.ParentGoCollectionAttr}}.{{.CollectionGoName}}
		}
	{{ end }}
	default:
		return nil
	}

}

func (p *{{.ParentGoName}}) SetCollectionParentKeyData(d interface{}, collection string) {
	switch collection {
	{{ range .Collections }}
	case "{{.CollectionName}}":
		p.{{.ParentGoKey}} = d.({{.ParentKeyGoType}})
	{{ end }}
	}
}

func (p *{{.ParentGoName}}) SetCollectionKeyData(pb interface{}, d interface{}, collection string) {
	switch collection {
	{{ range .Collections }}
	case "{{.CollectionName}}":
		pb.(*{{.CollectionDataTypeGoName}}).{{.CollectionGoKey}} = d.({{.CollectionKeyGoType}})
	{{ end }}
	}
}

func (p *{{.ParentGoName}}) SetCollectionKeyDataFromParent(pb interface{}, collection string) string {
	switch collection {
	{{ range .Collections }}
	case "{{.CollectionName}}":
		pb.(*{{.CollectionDataTypeGoName}}).{{.CollectionGoKey}} = p.{{.ParentGoKey}}
		return "{{.CollectionKey}}"
	{{ end }}
	}
	
	return ""
}

//Get the data for a collection from the parent, which is this protobuf
func (p *{{.ParentGoName}}) CollectionParentKeyData(collection string) interface{} {
	switch collection {
	{{ range .Collections }}
	case "{{.CollectionName}}":
		return p.{{.ParentGoKey}}
	{{ end }}
	default:
		return nil
	}
}

//Check if key belonging to the the parent (this protobuf) is default
func (p *{{.ParentGoName}}) CollectionParentKeyIsDefault(collection string) bool {
	switch collection {
	{{ range .Collections }}
	case "{{.CollectionName}}":
		return p.{{.ParentGoKey}} == {{.ParentKeyGoDefault}}
	{{ end }}
	default:
		return false
	}
}

//Check if the key belonging to an element that could be in the collection is default
//Will panic if pb is not the proper type, OR pb is nil, as it should
func (p *{{.ParentGoName}}) CollectionKeyIsDefault(pb interface{}, collection string) bool {
	switch collection {
	{{ range .Collections }}
	case "{{.CollectionName}}":
		return pb.(*{{.CollectionDataTypeGoName}}).{{.CollectionGoKey}} == {{.CollectionKeyGoDefault}}
	{{ end }}
	default:
		return false
	}
}

//Get the data for a collection from an element that could be in the collection
//Will panic if pb is not the proper type, as it should
func (p *{{.ParentGoName}}) CollectionKeyData(pb interface{}, collection string) interface{} {
	switch collection {
	{{ range .Collections }}
	case "{{.CollectionName}}":
		if pb == nil {
			return nil 
		} else {
			return pb.(*{{.CollectionDataTypeGoName}}).{{.CollectionGoKey}}
		}
	{{ end }}
	default:
		return nil
	}
}

func (p *{{.ParentGoName}}) ProtoBelongsToCollection(pb interface{}, collection string) bool {
	switch collection {
	{{ range .Collections }}
	case "{{.CollectionName}}":

		if c, ok := pb.(*{{.CollectionDataTypeGoName}}); ok {
			return c.{{.CollectionGoKey}} == p.{{.ParentGoKey}}
		} else {
			return false
		}
	{{ end }}
	default:
		return false
	}
}
`))

var listableCollectionTemplate = template.Must(template.New("listableCollection").Parse(`func (*{{.CollectionGoType}}) DefaultDetails() *pgcol.CollectionDetails {
	return &pgcol.CollectionDetails{
		ParentKey:     "{{.ParentKey}}",
		CollectionKey: "{{.CollectionKey}}",
		Listable:      true,
		Loaded:        false,
		MaxResults:     {{.MaxResults}},
		NextRPC:       "{{.NextRPC}}",
		NextBody:      nil,
	}
}

func (*{{.CollectionGoType}}) DataProto() proto.Message {
	return &{{.CollectionDataTypeGoName}}{}
}

func (c *{{.CollectionGoType}}) ClearData() {
	c.{{.CollectionDetailsGoName}} = c.DefaultDetails()
	c.{{.CollectionDetailsGoName}}.Loaded = false

	for i, _ := range c.{{.CollectionDataGoName}} {
		c.{{.CollectionDataGoName}}[i] = nil
	}

	c.{{.CollectionDataGoName}} = nil
}

func (c *{{.CollectionGoType}}) LoadData(data []interface{}) {

	c.{{.CollectionDetailsGoName}} = c.DefaultDetails()

	dL := len(data)

	if dL > 0 {

		c.{{.CollectionDataGoName}} = make([]*{{.CollectionDataTypeGoName}}, dL)

		for i, v := range data {
			if v != nil {
				c.{{.CollectionDataGoName}}[i] = v.(*{{.CollectionDataTypeGoName}})
			}
		}

		cL := len(c.{{.CollectionDataGoName}})

		if cL > 0 {
			if cL != dL {
				d := make([]*{{.CollectionDataTypeGoName}}, cL)
				copy(d, c.{{.CollectionDataGoName}})
				c.{{.CollectionDataGoName}} = nil
				c.{{.CollectionDataGoName}} = d
			}
		} else {
			c.{{.CollectionDataGoName}} = nil
		}

		c.{{.CollectionDetailsGoName}}.Loaded = true

	} else {
		c.{{.CollectionDetailsGoName}}.Loaded = true
	}

}

func (c *{{.CollectionGoType}}) LoadDataFromProto(data []proto.Message) {

	c.{{.CollectionDetailsGoName}} = c.DefaultDetails()

	dL := len(data)

	if dL > 0 {

		c.{{.CollectionDataGoName}} = make([]*{{.CollectionDataTypeGoName}}, dL)

		for i, v := range data {
			if v != nil {
				c.{{.CollectionDataGoName}}[i] = v.(*{{.CollectionDataTypeGoName}})
			}
		}

		cL := len(c.{{.CollectionDataGoName}})

		if cL > 0 {
			if cL != dL {
				d := make([]*{{.CollectionDataTypeGoName}}, cL)
				copy(d, c.{{.CollectionDataGoName}})
				c.{{.CollectionDataGoName}} = nil
				c.{{.CollectionDataGoName}} = d
			}
		} else {
			c.{{.CollectionDataGoName}} = nil
		}

		c.{{.CollectionDetailsGoName}}.Loaded = true

	} else {
		c.{{.CollectionDetailsGoName}}.Loaded = true
	}

}

func (c *{{.CollectionGoType}}) InterfaceSlice() []interface{} {
	if c.Data != nil {
		s := make([]interface{},len(c.Data))
		for idx, d := range c.Data {
			s[idx] = d
		}
		return s
	} else {
		return []interface{}{}
	}
}

func (c *{{.CollectionGoType}}) ProtoSlice() []proto.Message {
	if c.Data != nil {
		s := make([]proto.Message,len(c.Data))
		for idx, d := range c.Data {
			s[idx] = d
		}
		return s
	} else {
		return []proto.Message{}
	}
}
`))

var collectionTemplate = template.Must(template.New("collection").Parse(`func (*{{.CollectionGoType}}) DefaultDetails() *pgcol.CollectionDetails {
	return &pgcol.CollectionDetails{
		ParentKey:     "{{.ParentKey}}",
		CollectionKey: "{{.CollectionKey}}",
		Listable:      false,
		Loaded:        false,
		MaxResults:     {{.MaxResults}},
		NextRPC:       "{{.NextRPC}}",
		NextBody:      nil,
	}
}

func (*{{.CollectionGoType}}) DataProto() proto.Message {
	return &{{.CollectionDataTypeGoName}}{}
}

func (c *{{.CollectionGoType}}) ClearData() {
	c.{{.CollectionDetailsGoName}} = c.DefaultDetails()
	c.{{.CollectionDetailsGoName}}.Loaded = false

	c.{{.CollectionDataGoName}} = nil
}

func (c *{{.CollectionGoType}}) LoadData(data []interface{}) {

	c.{{.CollectionDetailsGoName}} = c.DefaultDetails()
	c.{{.CollectionDetailsGoName}}.Loaded = false

	if len(data) > 0 {
		for _, v := range data {
			if v != nil {
				c.{{.CollectionDataGoName}} = v.(*{{.CollectionDataTypeGoName}})
				c.{{.CollectionDetailsGoName}}.Loaded = true
				break
			}
		}

		if c.{{.CollectionDetailsGoName}}.Loaded != true {
			c.{{.CollectionDataGoName}} = &{{.CollectionDataTypeGoName}}{}
			c.{{.CollectionDetailsGoName}}.Loaded = true
		}
		

	} else {
		c.{{.CollectionDataGoName}} = &{{.CollectionDataTypeGoName}}{}
		c.{{.CollectionDetailsGoName}}.Loaded = true
	}

}

func (c *{{.CollectionGoType}}) LoadDataFromProto(data []proto.Message) {

	c.{{.CollectionDetailsGoName}} = c.DefaultDetails()
	c.{{.CollectionDetailsGoName}}.Loaded = false

	if len(data) > 0 {
		for _, v := range data {
			if v != nil {
				c.{{.CollectionDataGoName}} = v.(*{{.CollectionDataTypeGoName}})
				c.{{.CollectionDetailsGoName}}.Loaded = true
				break
			}
		}

		if c.{{.CollectionDetailsGoName}}.Loaded != true {
			c.{{.CollectionDataGoName}} = &{{.CollectionDataTypeGoName}}{}
			c.{{.CollectionDetailsGoName}}.Loaded = true
		}
		

	} else {
		c.{{.CollectionDataGoName}} = &{{.CollectionDataTypeGoName}}{}
		c.{{.CollectionDetailsGoName}}.Loaded = true
	}

}

func (c *{{.CollectionGoType}}) InterfaceSlice() []interface{} {
	if c.Data != nil {
		s := make([]interface{},1)
		s[0] = c.Data
		return s
	} else {
		var s []interface{}
		return s
	}
}

func (c *{{.CollectionGoType}}) ProtoSlice() []proto.Message {
	if c.Data != nil {
		s := make([]proto.Message,1)
		s[0] = c.Data
		return s
	} else {
		var s []proto.Message
		return s
	}
}
`))

var listableCollectionMessageSliceImplementingTemplate = template.Must(template.New("collectionMessageSliceImplementingTemplate").Parse(`func (c *{{.CollectionGoType}}) CollectionMessageSlice() []helpers.CollectionMessage {
	if c.Data != nil {
		s := make([]helpers.CollectionMessage,len(c.Data))
		for idx, d := range c.Data {
			s[idx] = d
		}
		return s
	}

	return nil
	
}

func (c *{{.CollectionGoType}}) DataIsCollectionMessage() bool {
	return true
}
`))

var collectionMessageSliceImplementingTemplate = template.Must(template.New("collectionMessageSliceImplementingTemplate").Parse(`func (c *{{.CollectionGoType}}) CollectionMessageSlice() []helpers.CollectionMessage {
	if c.Data != nil {
		s := make([]helpers.CollectionMessage,1)
		s[0] = c.Data
		return s
	}

	return nil
	
}

func (c *{{.CollectionGoType}}) DataIsCollectionMessage() bool {
	return true
}
`))

var collectionMessageSliceNotImplementingTemplate = template.Must(template.New("collectionMessageSliceNotImplementingTemplate").Parse(`func (c *{{.CollectionGoType}}) CollectionMessageSlice() []helpers.CollectionMessage {
	return nil
}

func (c *{{.CollectionGoType}}) DataIsCollectionMessage() bool {
	return false
}
`))

var collectionGapTemplate = template.Must(template.New("collectonGap").Parse(`func (g *{{.GapGoName}}) GapBridge() helpers.CollectionMessage {
	return g.{{.GapGoAttribute}}
}

func (g *{{.GapGoName}}) DefaultCollectionMap() map[string]helpers.CollectionElem {
	return g.{{.GapGoAttribute}}.DefaultCollectionMap()
}

func (g *{{.GapGoName}}) CollectionContainer() proto.Message {
	return g.{{.GapGoAttribute}}.CollectionContainer()
}

func (g *{{.GapGoName}}) CollectionKeys() []string {
	return g.{{.GapGoAttribute}}.CollectionKeys()
}

func (g *{{.GapGoName}}) LoadCollection(collection string, data []interface{}) error {
	return g.{{.GapGoAttribute}}.LoadCollection(collection, data)
}

func (g *{{.GapGoName}}) ClearCollection(collection string) error {
	return g.{{.GapGoAttribute}}.ClearCollection(collection)
}

func (g *{{.GapGoName}}) LoadCollectionFromProto(collection string, data []proto.Message) error {
	return g.{{.GapGoAttribute}}.LoadCollectionFromProto(collection, data)
}

func (g *{{.GapGoName}}) CollectionElem(collection string) helpers.CollectionElem{
	return g.{{.GapGoAttribute}}.CollectionElem(collection)
}

func (g *{{.GapGoName}}) CollectionInterfaceSlice(collection string) []interface{} {
	return g.{{.GapGoAttribute}}.CollectionInterfaceSlice(collection)
}

func (g *{{.GapGoName}}) CollectionProtoSlice(collection string) []proto.Message {
	return g.{{.GapGoAttribute}}.CollectionProtoSlice(collection)
}

func (g *{{.GapGoName}}) SetCollectionParentKeyData(d interface{}, collection string) {
	g.{{.GapGoAttribute}}.SetCollectionParentKeyData(d, collection)
}

func (g *{{.GapGoName}}) SetCollectionKeyData(pb interface{}, d interface{}, collection string) {
	g.{{.GapGoAttribute}}.SetCollectionKeyData(pb, d, collection)
}
func (g *{{.GapGoName}}) SetCollectionKeyDataFromParent(pb interface{}, collection string) string {
	return g.{{.GapGoAttribute}}.SetCollectionKeyDataFromParent(pb, collection)
}

func (g *{{.GapGoName}}) CollectionParentKeyData(collection string) interface{} {
	return g.{{.GapGoAttribute}}.CollectionParentKeyData(collection)
}

func (g *{{.GapGoName}}) CollectionParentKeyIsDefault(collection string) bool {
	return g.{{.GapGoAttribute}}.CollectionParentKeyIsDefault(collection)
}

func (g *{{.GapGoName}}) CollectionKeyIsDefault(pb interface{}, collection string) bool {
	return g.{{.GapGoAttribute}}.CollectionKeyIsDefault(pb, collection)
}

func (g *{{.GapGoName}}) CollectionKeyData(pb interface{}, collection string) interface{} {
	return g.{{.GapGoAttribute}}.CollectionKeyData(pb, collection)
}

func (g *{{.GapGoName}}) ProtoBelongsToCollection(pb interface{}, collection string) bool {
	return g.{{.GapGoAttribute}}.ProtoBelongsToCollection(pb, collection)
}
`))

var collectionLoaderTemplate = template.Must(template.New("collectonLoader").Parse(`// Code generated by protoc-gen-collections-go
// DO NOT EDIT!

package {{.GoPackage}}

import (
	"fmt"
	"sync"
	"errors"
	"github.com/willtrking/go-proto-collections/runtime"

	"golang.org/x/net/context"
)



////////////////////////////////////////////////////////////////////////////////
///// IMPLEMENT THIS INTERFACE!!
////////////////////////////////////////////////////////////////////////////////

type {{.CollectionDataTypeGoName}}Loader interface {
	{{ range .CLTypes }}
	From{{.CollectionGoKey}}(context.Context, string, []{{.CollectionKeyGoType}}, chan []*{{.CollectionDataTypeGoName}})
	{{ end }}	
}


////////////////////////////////////////////////////////////////////////////////
///// CALL THIS WITH THE IMPLEMENTATION OF ABOVE INTERFACE!!
////////////////////////////////////////////////////////////////////////////////

func Register{{.CollectionDataTypeGoName}}_Loader(r *runtime.CollectionRegistry, l {{.CollectionDataTypeGoName}}Loader) {
	{{ range .CLRegisterTypes }}
	r.RegisterLoader(&{{.CollectionGoType}}{}, New{{.CollectionDataTypeGoName}}_Loader(l))
	{{ end }}
}





type {{.CollectionDataTypeGoName}}_Loader struct {
	dataKey  string
	loadLock sync.Mutex
	waitLock sync.Mutex
	loading  bool
	loaded   bool
	once     sync.Once
	Data     []*{{.CollectionDataTypeGoName}}
	Loader   {{.CollectionDataTypeGoName}}Loader
}

func (c *{{.CollectionDataTypeGoName}}_Loader) DataKey() string { return c.dataKey }
func (c *{{.CollectionDataTypeGoName}}_Loader) Loading() bool { return c.loading }
func (c *{{.CollectionDataTypeGoName}}_Loader) Loaded() bool  { return c.loaded }
func (c *{{.CollectionDataTypeGoName}}_Loader) Wait() {
	c.waitLock.Lock()
	defer c.waitLock.Unlock()
}

func (c *{{.CollectionDataTypeGoName}}_Loader) SetDataKey(key string) error {

	switch key {
	{{ range .CLTypes }}
	case "{{.CollectionKey}}":
		c.dataKey = key
		return nil
	{{ end }}
	default:
		return errors.New(fmt.Sprintf("Unknown key %s",key))
	}

	return nil
}

func (c *{{.CollectionDataTypeGoName}}_Loader) InterfaceSlice() []interface{} {

	dL := len(c.Data)

	if dL > 0 {
		f := make([]interface{}, dL)

		for i, dI := range c.Data {
			func(y interface{}) {
				f[i] = y
			}(&*dI)
		}

		return f
	} else {
		return nil
	}

}


func (c *{{.CollectionDataTypeGoName}}_Loader) Load(ctx context.Context, from []interface{}) {
	//Need to acquire a lock here so we wait until the first call is done
	//Provides safety for InterfaceSlice()
	c.loadLock.Lock()
	defer c.loadLock.Unlock()

	loader := func() {
		c.loading = true
		defer func() { c.loading = false }()
		defer func() { c.loaded = true }()
		defer c.waitLock.Unlock()

		switch c.dataKey {
		{{ range .CLTypes }}
		case "{{.CollectionKey}}":
			var a []{{.CollectionKeyGoType}}
			lc := make(chan []*{{.CollectionDataTypeGoName}},1)

			for _, f := range from {
				if f != nil {
					a = append(a,f.({{.CollectionKeyGoType}}))
				}
			}
			
			if a != nil && len(a) > 0 {
				go c.Loader.From{{.CollectionGoKey}}(ctx, "{{.CollectionKey}}",a,lc)
				c.Data = <-lc
			}
		{{ end }}
		default:
			c.Data = nil	
		}

	}

	c.once.Do(loader)

}

func New{{.CollectionDataTypeGoName}}_Loader(l {{.CollectionDataTypeGoName}}Loader) func(string) (runtime.CollectionLoader,error) {

	return func(k string) (runtime.CollectionLoader,error) {
		f := &{{.CollectionDataTypeGoName}}_Loader{
			dataKey:  "",
			loadLock: sync.Mutex{},
			waitLock: sync.Mutex{},
			loading:  false,
			loaded:   false,
			once:     sync.Once{},
			Data:     []*{{.CollectionDataTypeGoName}}{},
			Loader:   l,
		}

		kErr := f.SetDataKey(k)
		if kErr != nil {
			return nil,kErr
		}

		f.waitLock.Lock()

		return f,nil
	}
}

`))

var collectionWriterTemplate = template.Must(template.New("collectionWriterTemplate").Parse(`// Code generated by protoc-gen-collections-go
// DO NOT EDIT!

package {{.GoPackage}}

import (
	"sync"
	"golang.org/x/net/context"
	"github.com/golang/protobuf/proto"
	"github.com/willtrking/go-proto-collections/runtime"
	"github.com/willtrking/go-proto-collections/helpers"
)



{{ range .CLTypes }}

type {{.CollectionDataTypeGoName}}_{{.ParentGoName}}_WriteData struct {
	*{{.CollectionDataTypeGoName}}
	GPCRWID uint64
}

{{ if .CollectionDataHasCollections }}	
type {{.CollectionDataTypeGoName}}_{{.ParentGoName}} struct {
	Data []*{{.CollectionDataTypeGoName}}_{{.ParentGoName}}_WriteData
	Parent *{{.ParentGoName}}
	collections map[uint64]*{{.CollectionDataCollectionGoName}}

}
{{ else }}
type {{.CollectionDataTypeGoName}}_{{.ParentGoName}} struct {
	Data []*{{.CollectionDataTypeGoName}}_{{.ParentGoName}}_WriteData
	Parent *{{.ParentGoName}}
}
{{ end }}

////////////////////////////////////////////////////////////////////////////////
///// IMPLEMENT THIS INTERFACE!!
////////////////////////////////////////////////////////////////////////////////

type {{.CollectionDataTypeGoName}}_{{.ParentGoName}}_Writer interface {
	Validate(context.Context, []*{{.CollectionDataTypeGoName}}_{{.ParentGoName}}) (context.Context, []runtime.WriterError)
	CheckPrecondition(context.Context, []*{{.CollectionDataTypeGoName}}_{{.ParentGoName}}) (context.Context, []runtime.WriterError)
	Write(context.Context, []*{{.CollectionDataTypeGoName}}_{{.ParentGoName}}) ([]*{{.CollectionDataTypeGoName}}_{{.ParentGoName}}_WriteData, []runtime.WriterError)
}

////////////////////////////////////////////////////////////////////////////////
///// CALL THIS WITH THE IMPLEMENTATION OF ABOVE INTERFACE!!
////////////////////////////////////////////////////////////////////////////////

func Register{{.CollectionDataTypeGoName}}_{{.ParentGoName}}_Writer(r *runtime.CollectionRegistry, l {{.CollectionDataTypeGoName}}_{{.ParentGoName}}_Writer) {
	
	r.RegisterWriter(&{{.CollectionGoType}}{}, New{{.CollectionGoType}}_Writer(l))
	
}

{{ end }}




{{ range .CLTypes }}

func(cwd *{{.CollectionDataTypeGoName}}_{{.ParentGoName}}) DataProtoSlice() []proto.Message {
	s := make([]proto.Message, len(cwd.Data))

	for idx, d := range cwd.Data {
		s[idx] = d.{{.CollectionDataTypeGoName}}
	}

	return s
}

func(cwd *{{.CollectionDataTypeGoName}}_{{.ParentGoName}}) ParentMessage() helpers.CollectionMessage{
	return cwd.Parent
}

func(cwd *{{.CollectionDataTypeGoName}}_{{.ParentGoName}}) ParentKey() string {
	d := &{{.CollectionGoType}}{}
	return d.DefaultDetails().ParentKey
}

func(cwd *{{.CollectionDataTypeGoName}}_{{.ParentGoName}}) CollectionKey() string {
	d := &{{.CollectionGoType}}{}
	return d.DefaultDetails().CollectionKey
}

func(cwd *{{.CollectionDataTypeGoName}}_{{.ParentGoName}}) ParentCollection() string {
	return "{{.CollectionName}}"
}

func(cwd *{{.CollectionDataTypeGoName}}_{{.ParentGoName}}) Listable() bool {
	d := &{{.CollectionGoType}}{}
	return d.DefaultDetails().Listable
}

type {{.CollectionGoType}}_Writer struct {
	readLock sync.Mutex
	validateLock sync.Mutex
	preconLock sync.Mutex
	writeLock sync.Mutex
	validateHadErrors bool
	preconHadErrors bool
	writeHadErrors bool
	reading  bool
	didRead   bool
	Data     []*{{.CollectionDataTypeGoName}}_{{.ParentGoName}}
	Writer   {{.CollectionDataTypeGoName}}_{{.ParentGoName}}_Writer
}

func (c *{{.CollectionGoType}}_Writer) Read(data []*runtime.ReadWriteContainer) {
	//Need to acquire a lock here so we wait until the first call is done
	//Provides safety for other functions in the chain
	c.readLock.Lock()
	defer c.readLock.Unlock()

	c.reading = true
	defer func() { c.reading = false }()
	defer func() { c.didRead = true }()

	c.Data = make([]*{{.CollectionDataTypeGoName}}_{{.ParentGoName}}, len(data))
	
	gpcrwid := 0

	for idx, f := range data {

		{{ if .CollectionDataHasCollections }}
		c.Data[idx] = &{{.CollectionDataTypeGoName}}_{{.ParentGoName}}{
			Data: make([]*{{.CollectionDataTypeGoName}}_{{.ParentGoName}}_WriteData,len(f.Data)),
			Parent: f.Parent.(*{{.ParentGoName}}),
			collections: make(map[uint64]*{{.CollectionDataCollectionGoName}},len(f.CollectionContainers)),
		}

		for didx, d := range f.Data {
			gpcrwid++

			c.Data[idx].Data[didx] = &{{.CollectionDataTypeGoName}}_{{.ParentGoName}}_WriteData{
				{{.CollectionDataTypeGoName}}: d.(*{{.CollectionDataTypeGoName}}),
				GPCRWID: uint64(gpcrwid),
			}
			
			if f.CollectionContainers[didx] == nil {
				c.Data[idx].collections[uint64(gpcrwid)] = nil
			} else {
				c.Data[idx].collections[uint64(gpcrwid)] = f.CollectionContainers[didx].(*{{.CollectionDataCollectionGoName}})
			}
			
		}
		{{ else }}
		c.Data[idx] = &{{.CollectionDataTypeGoName}}_{{.ParentGoName}}{
			Data: make([]*{{.CollectionDataTypeGoName}}_{{.ParentGoName}}_WriteData,len(f.Data)),
			Parent: f.Parent.(*{{.ParentGoName}}),
		}

		for didx, d := range f.Data {
			gpcrwid++

			c.Data[idx].Data[didx] = &{{.CollectionDataTypeGoName}}_{{.ParentGoName}}_WriteData{
				{{.CollectionDataTypeGoName}}: d.(*{{.CollectionDataTypeGoName}}),
				GPCRWID: uint64(gpcrwid),
			}
		}
		{{ end }}

	}




}


func (c *{{.CollectionGoType}}_Writer) Validate(ctx context.Context) (context.Context, []runtime.WriterError) {
	c.validateLock.Lock()
	defer c.validateLock.Unlock()

	nCtx, err := c.Writer.Validate(ctx, c.Data)

	if len(err) > 0 {
		c.validateHadErrors = true
	} else {
		c.validateHadErrors = false
	}

	return nCtx, err
}


func (c *{{.CollectionGoType}}_Writer) CheckPrecondition(ctx context.Context) (context.Context, []runtime.WriterError) {
	c.preconLock.Lock()
	defer c.preconLock.Unlock()

	nCtx, err := c.Writer.CheckPrecondition(ctx, c.Data)

	if len(err) > 0 {
		c.preconHadErrors = true
	} else {
		c.preconHadErrors = false
	}

	return nCtx, err
}

func (c *{{.CollectionGoType}}_Writer) Write(ctx context.Context) ([]helpers.CollectionWriterResponse, []runtime.WriterError) {
	c.writeLock.Lock()
	defer c.writeLock.Unlock()

	response, err := c.Writer.Write(ctx, c.Data)

	if len(err) > 0 {
		c.writeHadErrors = true
		return nil, err
	} else {
		c.writeHadErrors = false
	}

	asserted := make([]helpers.CollectionWriterResponse, len(c.Data))

	for idx, dat := range c.Data {
		dat.Parent.ClearCollection(dat.ParentCollection())

		var newCollectionData []interface{}
		var newData []*{{.CollectionDataTypeGoName}}_{{.ParentGoName}}_WriteData

		for _, r := range response {
			rd := r.{{.CollectionDataTypeGoName}}
			if dat.Parent.ProtoBelongsToCollection(rd, dat.ParentCollection()) {

				{{ if .CollectionDataHasCollections }}
				if _, hasCollections := dat.collections[r.GPCRWID]; hasCollections {
					rd.Collections = dat.collections[r.GPCRWID]
				}
				{{ end }}

				
				newCollectionData = append(newCollectionData, rd)
				newData = append(newData, r)
			}
		}


		if len(newCollectionData) > 0 {
			dat.Parent.LoadCollection(dat.ParentCollection(), newCollectionData)
		}

		for idx, _ := range dat.Data {
			dat.Data[idx] = nil
		}

		dat.Data = nil
		dat.Data = newData
		asserted[idx] = dat
	}


	return asserted, nil

}

func New{{.CollectionGoType}}_Writer(l {{.CollectionDataTypeGoName}}_{{.ParentGoName}}_Writer) func() (runtime.CollectionWriter,error) {

	return func() (runtime.CollectionWriter,error) {
		f := &{{.CollectionGoType}}_Writer{
			readLock: sync.Mutex{},
			validateLock: sync.Mutex{},
			preconLock: sync.Mutex{},
			writeLock: sync.Mutex{},
			validateHadErrors: false,
			preconHadErrors: false,
			writeHadErrors: false,
			reading:  false,
			didRead:   false,
			Data:     []*{{.CollectionDataTypeGoName}}_{{.ParentGoName}}{},
			Writer:   l,
		}

		return f,nil
	}
}

{{ end }}
`))
